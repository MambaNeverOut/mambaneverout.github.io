<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Irelia的博客  | React Hooks的API</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.58.3" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.d98f2eb6bcd1eaedb7edf166bd16af26.css" rel="stylesheet">
    

    

    
      
    

    
    
    <meta property="og:title" content="React Hooks的API" />
<meta property="og:description" content="useState  使用方法：
const [n,setN] = React.useState(0) const [user,setUser] = React.useState({name:&#39;F}) const [state,setState] = React.useState(()=&gt;({name:&#39;F})) // 可以接收函数，该函数返回初始state，且只执行一次  注意：
 不可以局部更新（需要自己合并属性，useReducer 也需要自己合并） 不能写到 if 中 对象的地址不变，内部改变，React 认为没有变化（要使用 setUser({})） setState(i =&gt; i &#43; 1)，需要对 state 进行多次 setState 的操作时，使用函数   useReducer  复杂版的 useState(用来践行 Flux/Redux 的思想)
 const initial = { n: 0 }; const reducer = (state, action) =&gt; { if (action.type === &quot;add&quot;) { return { n: state.n &#43; action." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mambaneverout.github.io/post/react-hooks%E7%9A%84api/" />
<meta property="article:published_time" content="2020-03-19T12:08:40+08:00" />
<meta property="article:modified_time" content="2020-03-19T12:08:40+08:00" />
<meta itemprop="name" content="React Hooks的API">
<meta itemprop="description" content="useState  使用方法：
const [n,setN] = React.useState(0) const [user,setUser] = React.useState({name:&#39;F}) const [state,setState] = React.useState(()=&gt;({name:&#39;F})) // 可以接收函数，该函数返回初始state，且只执行一次  注意：
 不可以局部更新（需要自己合并属性，useReducer 也需要自己合并） 不能写到 if 中 对象的地址不变，内部改变，React 认为没有变化（要使用 setUser({})） setState(i =&gt; i &#43; 1)，需要对 state 进行多次 setState 的操作时，使用函数   useReducer  复杂版的 useState(用来践行 Flux/Redux 的思想)
 const initial = { n: 0 }; const reducer = (state, action) =&gt; { if (action.type === &quot;add&quot;) { return { n: state.n &#43; action.">


<meta itemprop="datePublished" content="2020-03-19T12:08:40&#43;08:00" />
<meta itemprop="dateModified" content="2020-03-19T12:08:40&#43;08:00" />
<meta itemprop="wordCount" content="417">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="React Hooks的API"/>
<meta name="twitter:description" content="useState  使用方法：
const [n,setN] = React.useState(0) const [user,setUser] = React.useState({name:&#39;F}) const [state,setState] = React.useState(()=&gt;({name:&#39;F})) // 可以接收函数，该函数返回初始state，且只执行一次  注意：
 不可以局部更新（需要自己合并属性，useReducer 也需要自己合并） 不能写到 if 中 对象的地址不变，内部改变，React 认为没有变化（要使用 setUser({})） setState(i =&gt; i &#43; 1)，需要对 state 进行多次 setState 的操作时，使用函数   useReducer  复杂版的 useState(用来践行 Flux/Redux 的思想)
 const initial = { n: 0 }; const reducer = (state, action) =&gt; { if (action.type === &quot;add&quot;) { return { n: state.n &#43; action."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://mambaneverout.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      Irelia的博客
    </a>
    <div class="flex-l items-center">
      

      
      











    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        POSTS
      </p>
      <h1 class="f1 athelas mb1">React Hooks的API</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2020-03-19T12:08:40&#43;08:00">March 19, 2020</time>
      
      
    </header>

    <section class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l">

<h4 id="usestate">useState</h4>

<ul>
<li><p>使用方法：</p>

<pre><code>const [n,setN] = React.useState(0)
const [user,setUser] = React.useState({name:'F})
const [state,setState] = React.useState(()=&gt;({name:'F}))
// 可以接收函数，该函数返回初始state，且只执行一次
</code></pre></li>

<li><p>注意：</p>

<ul>
<li>不可以局部更新（需要自己合并属性，useReducer 也需要自己合并）</li>
<li>不能写到 if 中</li>
<li>对象的地址不变，内部改变，React 认为没有变化（要使用 setUser({})）</li>
<li>setState(i =&gt; i + 1)，需要对 state 进行多次 setState 的操作时，使用函数</li>
</ul></li>
</ul>

<h4 id="usereducer">useReducer</h4>

<ul>
<li><p>复杂版的 useState(用来践行 Flux/Redux 的思想)</p>

<pre><code>  const initial = { n: 0 };

  const reducer = (state, action) =&gt; {
    if (action.type === &quot;add&quot;) {
      return { n: state.n + action.number };
    } else if (action.type === &quot;multi&quot;) {
      return { n: state.n * 2 };
    } else {
      throw new Error(&quot;unknown type&quot;);
    }
  };

  function App() {
    const [state, dispatch] = useReducer(reducer, initial);
    const { n } = state;
    const onClick = () =&gt; {
      dispatch({ type: &quot;add&quot;, number: 1 });
    };
    const onClick2 = () =&gt; {
      dispatch({ type: &quot;add&quot;, number: 2 });
    };
    return (
      &lt;div className=&quot;App&quot;&gt;
        &lt;h1&gt;n: {n}&lt;/h1&gt;
        &lt;button onClick={onClick}&gt;+1&lt;/button&gt;
        &lt;button onClick={onClick2}&gt;+2&lt;/button&gt;
      &lt;/div&gt;
    );
  }
</code></pre></li>
</ul>

<h4 id="使用-usereducer-和-usecontext-代替-redux">使用 useReducer 和 useContext 代替 redux</h4>

<ul>
<li><p>步骤：</p>

<ul>
<li>将数据集中到一个 store 对象</li>
<li>将所有操作都集中到 reducer</li>
<li>创建一个 Context</li>
<li>创建对数据的读写 API</li>
<li>将 API 放入 Context</li>
<li>用 Content.Provider 将 Context 提供给所有组件</li>
<li>各个组件用 useContext 获取读写 API</li>
</ul></li>

<li><p>实例：<a href="https://codesandbox.io/s/sparkling-sound-pj4yd">https://codesandbox.io/s/sparkling-sound-pj4yd</a></p></li>
</ul>

<h4 id="usecontext">useContext</h4>

<ul>
<li>注意：使用 useContext 时，在后代组件使用 set 操作改变了值之后，后代组件会通知祖先，祖先进行对比找到要修改的后代组件，然后对修改的组件进行更新</li>
</ul>

<h4 id="useeffect-副作用">useEffect 副作用</h4>

<ul>
<li>对环境的改变即为副作用，可以理解为 afterRender</li>
<li>作为 componentDidMount 使用，[]作为第二个参数</li>
<li>作为 componentDidUpdate 使用，[]内写要监听的 state</li>
<li>作为 componentWillUnmount 使用，使用 return 一个函数</li>
<li>如果同时存在多个 useEffect，会按出现顺序执行</li>
</ul>

<h4 id="uselayouteffect-布局副作用">useLayoutEffect 布局副作用</h4>

<ul>
<li>useEffect 在浏览器渲染完成后执行</li>
<li>useLayoutEffect 在浏览器渲染前执行</li>
<li>如果 useLayoutEffect 中的操作不影响布局，使用 useEffect 代替它</li>
</ul>

<h4 id="usememo">useMemo</h4>

<ul>
<li><p>memo</p>

<ul>
<li>React.memo()，使用 memo 可以让组件只在自身的 props 变化后执行，避免多余的 render，节省性能</li>

<li><p>如果祖先组件为该后代组件添加了监听函数，因为祖先组件更新后会重新执行，就会得到新的监听函数，地址变化导致后代组件 render</p>

<pre><code>const Child = React.memo(props =&gt; {
console.log(&quot;child 执行了&quot;);
console.log(&quot;假设这里有大量代码&quot;);
return &lt;div&gt;child: {props.data}&lt;/div&gt;;
});
</code></pre></li>
</ul></li>

<li><p>useMemo &ndash;&gt; (Vue2 computed)???</p>

<ul>
<li>第一个参数是()=&gt;value</li>
<li>第二个参数是依赖[m,n]</li>
<li>只有当依赖变化时，才会计算新的 value</li>
<li>如果依赖不变就重用之前的 value</li>
<li>那么如果 value 是个函数，就要写成
<code>useMemo(()=&gt;(x)=&gt;console.log(x),[m])</code></li>
</ul></li>

<li><p>useCallback 语法糖</p>

<ul>
<li>可以使用<code>useCallback(x =&gt; console.log(x),[m])</code>代替 <code>useMemo(()=&gt;(x)=&gt;console.log(x), [m])</code></li>
</ul></li>
</ul>

<h4 id="useref">useRef</h4>

<ul>
<li>需要一个值，在组件不断 render 时保持不变</li>
<li>初始化：const count = useRef(0)</li>
<li>读取：count.current</li>
<li>为什么需要 current？ 保证两次 useRef 是同一个值</li>
</ul>

<h4 id="vue3-ref">Vue3 ref</h4>

<ul>
<li>初始化： const count = ref(0)</li>
<li>读取：count.value</li>
<li>不同点：count.value 变化时，会自动 render 更新 UI</li>
</ul>

<h4 id="forwardref">forwardRef</h4>

<ul>
<li><p>props 不包含 ref 属性，无法传递 ref 属性</p></li>

<li><p>函数组件无法直接接收传入的 ref 属性</p>

<pre><code>  function App(){
    const buttonRef = useRef(null)
    return (
      &lt;div className=&quot;App&quot;&gt;
        &lt;Button ref={buttonRef}&gt;按钮&lt;/Button&gt;
      &lt;/div&gt;
    )
  }
  const Button = React.forwardRef((props, ref)=&gt;{
    return &lt;button ref={ref} {...props}/&gt;
  })
</code></pre></li>
</ul>

<h4 id="useimperativehandle">useImperativeHandle</h4>

<ul>
<li><p>可以理解为 setRef，自定义 ref 的属性</p>

<pre><code>  const Button2 = React.forwardRef((props, ref) =&gt; {
    const realButton = createRef(null);
    const setRef = useImperativeHandle;
    setRef(ref, () =&gt; {
      return {
        x: () =&gt; {
          realButton.current.remove();
        },
        realButton: realButton
      };
    });
    return &lt;button ref={realButton} {...props} /&gt;;
  });
</code></pre></li>
</ul>

<h4 id="自定义-hook">自定义 Hook</h4>

<ul>
<li>自定义 Hook 里使用 Context</li>

<li><p>可以代替 redux</p>

<pre><code>  const useList = () =&gt; {
    const [list, setList] = useState(null);
    useEffect(() =&gt; {
      ajax(&quot;/list&quot;).then(list =&gt; {
        setList(list);
      });
    }, []); // [] 确保只在第一次运行
    return {
      list: list,
      addItem: name =&gt; {
        setList([...list, { id: Math.random(), name: name }]);
      },
      deleteIndex: index =&gt; {
        setList(list.slice(0, index).concat(list.slice(index + 1)));
      }
    };
  };
  export default useList;
</code></pre></li>
</ul>
<ul class="pa0">
  
</ul>
<div class="mt6">
      
      
      </div>
    </section>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://mambaneverout.github.io/" >
    &copy; 2020 Irelia的博客
  </a>
    <div>










</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
