<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Irelia的博客  | Vue数据响应式</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.58.3" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.d98f2eb6bcd1eaedb7edf166bd16af26.css" rel="stylesheet">
    

    

    
      
    

    
    
    <meta property="og:title" content="Vue数据响应式" />
<meta property="og:description" content="“Vue 是一套用于构建用户界面的渐进式框架，Vue 的核心库只关注视图层。” Vue 文档已经把 Vue 的特点说的很清楚了，Vue 是专注于 UI 界面的框架，数据的修改会实时的反馈到界面中。这就是数据响应式了，通过数据来驱动视图。 在 Vue 文档深入响应式原理中，Vue 是这样说的：“ 当你把一个对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。 ”那么 Vue 具体是怎么做的呢？
Vue 响应式原理: https://cn.vuejs.org/v2/guide/reactivity.html
1.先来了解一下 getter, setter 和 Object.defineProperty  getter: 不要括号就可以调用的函数
let obj2 = { 姓: &quot;高&quot;, 名: &quot;圆圆&quot;, get name() { return this.姓 &#43; this.名; }, }; console.log(&quot;需求二：&quot; &#43; obj2.name);  setter: 传入一个值并把这个值赋值给其他变量
let obj3 = { 姓: &quot;高&quot;, 名: &quot;圆圆&quot;, get name() { return this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mambaneverout.github.io/post/vue%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/" />
<meta property="article:published_time" content="2019-12-20T09:20:32+08:00" />
<meta property="article:modified_time" content="2019-12-20T09:20:32+08:00" />
<meta itemprop="name" content="Vue数据响应式">
<meta itemprop="description" content="“Vue 是一套用于构建用户界面的渐进式框架，Vue 的核心库只关注视图层。” Vue 文档已经把 Vue 的特点说的很清楚了，Vue 是专注于 UI 界面的框架，数据的修改会实时的反馈到界面中。这就是数据响应式了，通过数据来驱动视图。 在 Vue 文档深入响应式原理中，Vue 是这样说的：“ 当你把一个对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。 ”那么 Vue 具体是怎么做的呢？
Vue 响应式原理: https://cn.vuejs.org/v2/guide/reactivity.html
1.先来了解一下 getter, setter 和 Object.defineProperty  getter: 不要括号就可以调用的函数
let obj2 = { 姓: &quot;高&quot;, 名: &quot;圆圆&quot;, get name() { return this.姓 &#43; this.名; }, }; console.log(&quot;需求二：&quot; &#43; obj2.name);  setter: 传入一个值并把这个值赋值给其他变量
let obj3 = { 姓: &quot;高&quot;, 名: &quot;圆圆&quot;, get name() { return this.">


<meta itemprop="datePublished" content="2019-12-20T09:20:32&#43;08:00" />
<meta itemprop="dateModified" content="2019-12-20T09:20:32&#43;08:00" />
<meta itemprop="wordCount" content="385">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Vue数据响应式"/>
<meta name="twitter:description" content="“Vue 是一套用于构建用户界面的渐进式框架，Vue 的核心库只关注视图层。” Vue 文档已经把 Vue 的特点说的很清楚了，Vue 是专注于 UI 界面的框架，数据的修改会实时的反馈到界面中。这就是数据响应式了，通过数据来驱动视图。 在 Vue 文档深入响应式原理中，Vue 是这样说的：“ 当你把一个对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。 ”那么 Vue 具体是怎么做的呢？
Vue 响应式原理: https://cn.vuejs.org/v2/guide/reactivity.html
1.先来了解一下 getter, setter 和 Object.defineProperty  getter: 不要括号就可以调用的函数
let obj2 = { 姓: &quot;高&quot;, 名: &quot;圆圆&quot;, get name() { return this.姓 &#43; this.名; }, }; console.log(&quot;需求二：&quot; &#43; obj2.name);  setter: 传入一个值并把这个值赋值给其他变量
let obj3 = { 姓: &quot;高&quot;, 名: &quot;圆圆&quot;, get name() { return this."/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://mambaneverout.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      Irelia的博客
    </a>
    <div class="flex-l items-center">
      

      
      











    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        POSTS
      </p>
      <h1 class="f1 athelas mb1">Vue数据响应式</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2019-12-20T09:20:32&#43;08:00">December 20, 2019</time>
      
      
    </header>

    <section class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l">

<h4 id="vue-是一套用于构建用户界面的渐进式框架-vue-的核心库只关注视图层-vue-文档已经把-vue-的特点说的很清楚了-vue-是专注于-ui-界面的框架-数据的修改会实时的反馈到界面中-这就是数据响应式了-通过数据来驱动视图">“Vue 是一套用于构建用户界面的渐进式框架，Vue 的核心库只关注视图层。” Vue 文档已经把 Vue 的特点说的很清楚了，Vue 是专注于 UI 界面的框架，数据的修改会实时的反馈到界面中。这就是数据响应式了，通过数据来驱动视图。</h4>

<p>在 Vue 文档深入响应式原理中，Vue 是这样说的：“
<strong>当你把一个对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。</strong>
”那么 Vue 具体是怎么做的呢？</p>

<p>Vue 响应式原理: <a href="https://cn.vuejs.org/v2/guide/reactivity.html">https://cn.vuejs.org/v2/guide/reactivity.html</a></p>

<h4 id="1-先来了解一下-getter-setter-和-object-defineproperty">1.先来了解一下 getter, setter 和 Object.defineProperty</h4>

<ul>
<li><p>getter: 不要括号就可以调用的函数</p>

<pre><code>let obj2 = {
  姓: &quot;高&quot;,
  名: &quot;圆圆&quot;,
  get name() {
    return this.姓 + this.名;
  },
};
console.log(&quot;需求二：&quot; + obj2.name);
</code></pre></li>

<li><p>setter: 传入一个值并把这个值赋值给其他变量</p>

<pre><code>let obj3 = {
  姓: &quot;高&quot;,
  名: &quot;圆圆&quot;,
  get name() {
    return this.姓 + this.名;
  },
  set name(xxx){
    this.姓 = xxx[0]
    this.名 = xxx.slice(1)
  },
};
obj3.name = '高媛媛'
console.log(`需求三：姓 ${obj3.姓}，名 ${obj3.名}`)
</code></pre></li>

<li><p>Object.defineProperty: 可以给对象添加属性 value，可以给对象的属性添加 getter 和 setter，对属性的读写进行监控</p>

<pre><code>let _name = '王尼玛'
Object.defineProperty(obj3, 'myName', {
  get(){
    return _name
  },
  set(value){
    _name = value
  }
})
</code></pre></li>
</ul>

<h4 id="2-代理-设计模式">2.代理(设计模式)</h4>

<ul>
<li><p>n 不能设置为小于 0 的数字(可以通过直接对 data._n 进行赋值，绕过了 Object.defineProperty)</p>

<pre><code>let data = {}
data._n = 0  // data._n = -1
Object.defineProperty(data, 'n', {
    get(){
      return this._n
    },
    set(value){
      if(value &lt; 0) return
      this._n = value
    }
})
</code></pre></li>

<li><p>设置为匿名对象，让你无法访问，也就无法修改(
为匿名对象添加名字，修改匿名对象，又绕开了)</p>

<pre><code>// let myData = {data:{n:0}}
// let data = proxy(data:myData)
let data = proxy({ data:{n:0} }) // 括号里是匿名对象，无法访问
function proxy({data}){
    const obj = {}
    Object.defineProperty(obj, 'n', {
      get(){
        return data.n
      },
      set(value){
        if(value&lt;0)return
        data.n = value
      }
    })
    return obj // obj 就是代理
}
</code></pre></li>

<li><p>把 myData 监听起来，myData.n 也无法设置为小于 0 的数值(最终方案)</p>

<pre><code>let myData = {n:0}
let data = proxy({ data:myData })
function proxy({data}){
    let value = data.n  // 监听 data
     // delete data.n   可以不写，下面的代码会把data.n覆盖掉
    Object.defineProperty(data, 'n', {
        get(){
          return value
        },
        set(newValue){
          if(newValue&lt;0)return
          value = newValue
        }
    })
    const obj = {}
    Object.defineProperty(obj, 'n', {
        get(){
          return data.n
        },
        set(value){
            data.n = value
        }
    })
    return obj // obj 就是代理
}
</code></pre></li>

<li><p>Vue 其实就是让 vm 成为 myData 的代理
(proxy)，然后对 myData 的所有属性进行监控，如果属性有所改变，就会调用 render 函数重新渲染页面。</p></li>
</ul>

<h4 id="3-数据响应式失效的例子">3.数据响应式失效的例子：</h4>

<ul>
<li><p>data 存在一个 bug(数据没有提前声明导致不会在页面中显示)</p>

<ul>
<li>obj.b 并没有声明，所以不会被监听(Vue 只会检查第一层属性)</li>

<li><p>Vue.set / this.\$set 自动创建代理和监听，触发 UI 更新</p>

<pre><code>new Vue({
  data:{
    obj: {
      a:0
    }
  },
  template: `
    &lt;div&gt;
      {{obj.b}}
      &lt;button @click=&quot;setB&quot;&gt;set B&lt;/button&gt;
    &lt;/div&gt;
  `,
  methods:{
    setB(){
      this.obj.b = 1  // Vue没有监听，所以不会显示
      Vue.set(this.obj, 'b', 1)
      this.$set(this.obj, 'b', 1)
    }
  }
}).$mount('#app')
</code></pre></li>
</ul></li>
</ul>

<h4 id="4-vue-内部对-array-的方法的加工">4.Vue 内部对 array 的方法的加工</h4>

<ul>
<li><p>array 无法提前声明，可以使用 Vue.set 但没必要。Vue 篡改了数组的部分 API，使我们可以直接使用(<a href="https://cn.vuejs.org/v2/guide/list.html#%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%95-mutation-method">https://cn.vuejs.org/v2/guide/list.html#%E5%8F%98%E5%BC%82%E6%96%B9%E6%B3%95-mutation-method</a>)</p>

<pre><code>new Vue({
    data:{
      array: ['a', 'b', 'c']
    },
    template: `
      &lt;div&gt;
        {{obj.b}}
        &lt;button @click=&quot;setD&quot;&gt;set D&lt;/button&gt;
      &lt;/div&gt;
    `,
    methods:{
      setD(){
        this.array[3] = 'd'
        this.array.push('d') // 被修改过的push方法
      }
    }
}).$mount('#app')
</code></pre></li>

<li><p>Vue 内部把数组的每一项都进行了监听，并在我们 push 的时候，直接调用了数组原生 API</p>

<pre><code>class VueArray extends Array{
    push(...args){
      const oldLength = this.length
      super.push(...args)
      for(let i = oldLength; i &lt; this.length; i++){
        Vue.set(this, i, this[i])
      }
    }
}
</code></pre></li>
</ul>
<ul class="pa0">
  
</ul>
<div class="mt6">
      
      
      </div>
    </section>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://mambaneverout.github.io/" >
    &copy; 2020 Irelia的博客
  </a>
    <div>










</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
