<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Irelia的博客  | 正则表达式</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.58.3" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.d98f2eb6bcd1eaedb7edf166bd16af26.css" rel="stylesheet">
    

    

    
      
    

    
    
    <meta property="og:title" content="正则表达式" />
<meta property="og:description" content="浅拷贝（只拷贝数据的第一层） const shadowCopy = arr =&gt; arr.map(v =&gt; v) // 数组拷贝 function shadowCopy(src) { let result = Array.isArray(src) ? [] : {} for(let key in src){ result[key] = src[key] } return result }  深拷贝 function deepCopy(src){ let result = Array.isArray(src) ? [] : {} for(let key in src){ if( typeof src[key] === &#39;object&#39; &amp;&amp; src[key] !== null) { result[key] = deepCopy(src[key]) } else { result[key] = src[key] } } return result }  正则表达式 创建  字面量方式创建" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mambaneverout.github.io/post/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" />
<meta property="article:published_time" content="2019-12-31T12:52:45+08:00" />
<meta property="article:modified_time" content="2019-12-31T12:52:45+08:00" />
<meta itemprop="name" content="正则表达式">
<meta itemprop="description" content="浅拷贝（只拷贝数据的第一层） const shadowCopy = arr =&gt; arr.map(v =&gt; v) // 数组拷贝 function shadowCopy(src) { let result = Array.isArray(src) ? [] : {} for(let key in src){ result[key] = src[key] } return result }  深拷贝 function deepCopy(src){ let result = Array.isArray(src) ? [] : {} for(let key in src){ if( typeof src[key] === &#39;object&#39; &amp;&amp; src[key] !== null) { result[key] = deepCopy(src[key]) } else { result[key] = src[key] } } return result }  正则表达式 创建  字面量方式创建">


<meta itemprop="datePublished" content="2019-12-31T12:52:45&#43;08:00" />
<meta itemprop="dateModified" content="2019-12-31T12:52:45&#43;08:00" />
<meta itemprop="wordCount" content="366">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="正则表达式"/>
<meta name="twitter:description" content="浅拷贝（只拷贝数据的第一层） const shadowCopy = arr =&gt; arr.map(v =&gt; v) // 数组拷贝 function shadowCopy(src) { let result = Array.isArray(src) ? [] : {} for(let key in src){ result[key] = src[key] } return result }  深拷贝 function deepCopy(src){ let result = Array.isArray(src) ? [] : {} for(let key in src){ if( typeof src[key] === &#39;object&#39; &amp;&amp; src[key] !== null) { result[key] = deepCopy(src[key]) } else { result[key] = src[key] } } return result }  正则表达式 创建  字面量方式创建"/>

  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="https://mambaneverout.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      Irelia的博客
    </a>
    <div class="flex-l items-center">
      

      
      











    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">

    <header class="mt4 w-100">
      <p class="f6 b helvetica tracked">
          
        POSTS
      </p>
      <h1 class="f1 athelas mb1">正则表达式</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2019-12-31T12:52:45&#43;08:00">December 31, 2019</time>
      
      
    </header>

    <section class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l">

<h3 id="浅拷贝-只拷贝数据的第一层">浅拷贝（只拷贝数据的第一层）</h3>

<pre><code>const shadowCopy = arr =&gt; arr.map(v =&gt; v) // 数组拷贝
function shadowCopy(src) {
  let result = Array.isArray(src) ? [] : {}
  for(let key in src){
    result[key] = src[key]
  }
  return result
}
</code></pre>

<h3 id="深拷贝">深拷贝</h3>

<pre><code>function deepCopy(src){
  let result = Array.isArray(src) ? [] : {}
  for(let key in src){
    if( typeof src[key] === 'object' &amp;&amp; src[key] !== null) {
      result[key] = deepCopy(src[key])
    } else {
      result[key] = src[key]
    }
  }
  return result
}
</code></pre>

<h3 id="正则表达式">正则表达式</h3>

<h4 id="创建">创建</h4>

<ul>
<li><p>字面量方式创建</p>

<pre><code>let reg = /\+86\d{11}/g
</code></pre></li>

<li><p>构造函数方式创建(正则规则可以通过字符串拼接)</p>

<pre><code>let reg = new RegExp('+86\d{11}', 'g')
</code></pre></li>

<li><p>reg.test(str) // 查看正则表达式与指定的字符串是够匹配</p></li>
</ul>

<h4 id="修饰符">修饰符</h4>

<ul>
<li>g: global 全文搜索(默认只搜索第一个匹配的结果)</li>
<li>i: ingore case 忽略大小写(默认大小写敏感)</li>
<li>m: multiple lines 多行搜索</li>
</ul>

<h4 id="范围匹配">范围匹配</h4>

<ul>
<li><p>[abcd] 匹配一个字符，可以是 a b c d 中的任意一个</p></li>

<li><p>[0-9] 匹配一个是 0 到 9 的数字</p></li>

<li><p>[a-zA-Z] 匹配一个不限制大小写的字母</p></li>

<li><p>[^abc] 表示一个不是字符 a 或 b 或 c 的字符</p></li>
</ul>

<h4 id="预定义匹配">预定义匹配</h4>

<ul>
<li>. 等价于 [^\r\n]，匹配一个除回车和换行以为的任意字符</li>
<li>\d 等价于[0-9]，匹配一个数字字符</li>
<li>\D 等价于[^0-9]， 匹配一个非数字字符</li>
<li>\s 等价于[空格\t\n\r\v\f]，匹配一个空白字符</li>
<li>\S 等价于[^空格\t\n\r\v\f]，匹配一个非空白字符</li>
<li>\w 等价于[a-zA-Z_0-9]，匹配一个字母、数字、下划线</li>
<li>\W 等价于[^a-za-z_0-9]，匹配一个非单词字符</li>
</ul>

<h4 id="匹配一次或多次">匹配一次或多次</h4>

<ul>
<li>? 前面的字符出现 0 次或者 1 次</li>
<li>+前面的字符出现 1 次或者多次</li>
<li>- 前面的字符出现 0 次或者多次</li>
<li>{n} 前面的字符出现 n 次</li>
<li>{n,m} 前面的字符出现 n 到 m 次</li>
<li>{n,} 前面的字符出现至少 n 次</li>
</ul>

<h4 id="边界">边界</h4>

<ul>
<li>/^xyz/ 以 xyz 开头</li>
<li><code>/abc$/</code> 以 abc 结尾</li>
<li>/\babc\b/ 匹配是单词的 abc (左右两侧是字符串开头、结尾、中横线、空格) \b 表示单词边界</li>
<li>/\Babc\B/ 匹配不是单词的 abc</li>
</ul>

<h4 id="实例">实例</h4>

<ul>
<li><p>匹配手机号</p>

<pre><code>/^1\d{10}$/ // 以1开头长度为11的数字
/^(\+86)?1[358]\d{9}$/ // 以+86或者1开头，3或者5或者8为第二位的长度为11的数字
</code></pre></li>

<li><p>匹配邮箱</p>

<pre><code>规则: 字符串中间包含一个@，@后面包含一个.
/^[^@\s]+@[^@\s]+\.[^@/s]+$/
</code></pre></li>

<li><p>匹配用户名</p>

<pre><code>规则: 合法用户至少8位至多15位，包含大写、小写、数字、下划线至少两种
function validUsername(rawInput) {
  if(!/^\w{8,15}$/.test(rawInput)) return false
  if(/(^[a-z]+$)|(^[A-Z]+$)|(^[0-9]+$)|(^_+$)/.test(rawInput)) return false
  return true
}
</code></pre></li>

<li><p>字符串方法</p>

<pre><code>'a1b2c3'.search(/\d/) // 0
'a1b2c3'.match(/\d/g) //['1', '2', '3']
'a1b2c3'.replace(/\d/g, 'x') //'axbxcx'
'a1a2c3'.replace(/a(\d)/g, 'A$1') //'A1A2c3'
'a1b2c3'.replace(/\d/g, function(matched, $1, index) { })
'1 2 3'.split(/\s/) //['1', '2', '3']
</code></pre></li>
</ul>

<h4 id="贪婪模式">贪婪模式</h4>

<ul>
<li><p>默认是贪婪模式(尽可能多的匹配)，如果想使用贪婪模式可以在量词后加?即可</p>

<pre><code>'123456789'.match(/\d{3,5}?/g)
</code></pre></li>
</ul>

<h4 id="分组">分组</h4>

<pre><code>/(hello)|(hi) world/ //匹配 “hello world” 和 “hi world”
&quot;hello8 world, hello6 reg&quot;.replace(/hello(\d)/g, 'hi$1') // $1代表正则里分组匹配的内容，输出 “hi8 world, hi6 reg”
</code></pre>

<h4 id="前瞻">前瞻</h4>

<ul>
<li>exp1(?=exp2) // 匹配后面是 exp2 的 exp1</li>

<li><p>exp1(?!exp2) // 匹配后面不是 exp2 的 exp1</p>

<pre><code>/hello(?=reg)/.test('reg') //true
/hello(?=reg)/.test('helloWorld) //false
/hello(?!reg)/.test('helloWorld') //true
</code></pre></li>
</ul>

<h4 id="regexp-prototype-exec">RegExp.prototype.exec</h4>

<ul>
<li><p>调用全局的 RegExp 对象的 exec()时，它会在 RegExp 实例的 lastIndex 属性指定的字符处开始检索字符串 string</p>

<ul>
<li>当 exec()找到了与表达式相匹配的文本时，在匹配后，它将把 RegExp 实例的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。可以通过反复调用 exec()方法来遍历字符串中的所有匹配文本</li>

<li><p>当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0</p>

<pre><code>let reg = /\b\w+\b/g, temp
while(temp = reg.exec('hello world, hi reg')) {
  console.log(`${temp.index} : ${temp[0]}`)
}
/*输出
0 : hello
6 : world
13 : hello
19 : reg
*/
</code></pre></li>
</ul></li>
</ul>

<h4 id="string-prototype-replace-reg-function">String.prototype.replace(reg, function)</h4>

<ul>
<li><p>第二个参数传入一个 function，会在每次匹配替换的时候调用，返回值为要替换的内容，回调函数一共有 <sup>3</sup>&frasl;<sub>4</sub> 个参数</p>

<ul>
<li>第一个参数很简单，是匹配字符串</li>
<li>第二个参数是正则表达式分组内容，若没有分组则没有该参数</li>
<li>第三个参数是匹配项在字符串中的 index，若没有分组该为第二个参数</li>

<li><p>第四个参数则是原字符串，若没有分组该为第三个参数</p>

<pre><code>//把字符串转换成驼峰形式
let str = 'border-top-color'
const strToCamel = str =&gt;
  str.replace(/-(\w)/g, (match, $1) =&gt; $1.toUpperCase())
console.log( strToCamel(str) )
</code></pre></li>
</ul></li>
</ul>
<ul class="pa0">
  
</ul>
<div class="mt6">
      
      
      </div>
    </section>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://mambaneverout.github.io/" >
    &copy; 2020 Irelia的博客
  </a>
    <div>










</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
