<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Irelia的博客</title>
    <link>https://mambaneverout.github.io/</link>
    <description>Recent content on Irelia的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <lastBuildDate>Sun, 05 Jan 2020 12:42:18 +0800</lastBuildDate>
    
	<atom:link href="https://mambaneverout.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>JS事件</title>
      <link>https://mambaneverout.github.io/post/js%E4%BA%8B%E4%BB%B6/</link>
      <pubDate>Sun, 05 Jan 2020 12:42:18 +0800</pubDate>
      
      <guid>https://mambaneverout.github.io/post/js%E4%BA%8B%E4%BB%B6/</guid>
      <description>事件捕获与事件冒泡  DOM 事件流三个阶段：事件捕获阶段，处于目标阶段，事件冒泡阶段  事件绑定 addEventListener  target.addEventListener(type, listener, options)
 type: 事件类型 listener: 事件处理函数 options: 可选，默认都为 false。 {capture:是否捕获阶段监听，once:是否只监听一次，passive:是否忽略 preventDefault}  target.addEventListener(type, listener, useCapture)
 useCapture:可选，true 表示在捕获阶段调用 listener，false 表示在冒泡阶段调用 listener  target.removeEventListener
 target.removeEventListener(&amp;lsquo;click&amp;rsquo;, handler) target.removeEventListener(&amp;lsquo;click&amp;rsquo;, handler, true)
$btn.onclick = function(e) { console.log(&#39;点了&#39;) } $btn.addEventListener(&#39;click&#39;, function(e){ console.log(&#39;点&#39;) }, true)    阻止事件传播  e.stopPropagation()  阻止默认行为  e.preventDefault()
$form.addEventListener(&#39;submit&#39;, function(e) { e.preventDefault() if(validUsername($username.value)) { // 表单提交前校验 this.submit() } else { $error.</description>
    </item>
    
    <item>
      <title>正则表达式</title>
      <link>https://mambaneverout.github.io/post/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Tue, 31 Dec 2019 12:52:45 +0800</pubDate>
      
      <guid>https://mambaneverout.github.io/post/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>浅拷贝（只拷贝数据的第一层） const shadowCopy = arr =&amp;gt; arr.map(v =&amp;gt; v) // 数组拷贝 function shadowCopy(src) { let result = Array.isArray(src) ? [] : {} for(let key in src){ result[key] = src[key] } return result }  深拷贝 function deepCopy(src){ let result = Array.isArray(src) ? [] : {} for(let key in src){ if( typeof src[key] === &#39;object&#39; &amp;amp;&amp;amp; src[key] !== null) { result[key] = deepCopy(src[key]) } else { result[key] = src[key] } } return result }  正则表达式 创建  字面量方式创建</description>
    </item>
    
    <item>
      <title>Vue指令和修饰符</title>
      <link>https://mambaneverout.github.io/post/vue%E6%8C%87%E4%BB%A4%E5%92%8C%E4%BF%AE%E9%A5%B0%E7%AC%A6/</link>
      <pubDate>Sun, 29 Dec 2019 12:14:52 +0800</pubDate>
      
      <guid>https://mambaneverout.github.io/post/vue%E6%8C%87%E4%BB%A4%E5%92%8C%E4%BF%AE%E9%A5%B0%E7%AC%A6/</guid>
      <description>template(模板)  写在 HTMl 中(Vue 完整版)
&amp;lt;div id=&amp;quot;xxx&amp;quot;&amp;gt; {{n}} &amp;lt;button @click=&amp;quot;add&amp;quot;&amp;gt;+1&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; new Vue({ el: &#39;#app&#39;, data: {n:0}, // data可以改成函数 methods: {add(){}} })  写在 options 中(Vue 完整版)
&amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; // div#app会被替换 new Vue({ template: ` &amp;lt;div&amp;gt; {{n}} &amp;lt;button @click=&amp;quot;add&amp;quot;&amp;gt;+1&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; `, data: {n:0}, // data可以改成函数 methods: {add(){}} }).$mounted(&#39;#app&#39;)  配合 xxx.vue 文件(Vue 非完整版)
template 使用的是XML，语法严格，体积小，更适合写编译器 &amp;lt;template&amp;gt; &amp;lt;div&amp;gt; &amp;lt;button @click=&amp;quot;add&amp;quot;&amp;gt; +1 &amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; export default{ data(){ return { n:0 }}, // data必须为函数 methods:{add(){}} } &amp;lt;/script&amp;gt;  // 在其他地方引入 import Xxx from &#39;.</description>
    </item>
    
    <item>
      <title>Computed和watch</title>
      <link>https://mambaneverout.github.io/post/computed%E5%92%8Cwatch/</link>
      <pubDate>Mon, 23 Dec 2019 11:40:56 +0800</pubDate>
      
      <guid>https://mambaneverout.github.io/post/computed%E5%92%8Cwatch/</guid>
      <description>computed  computed 默认只有 getter，需要的时候也可以提供 setter
 computed:{ displayName: { get(){ const user = this.user return user.nickname || user.phone || user.email } set(value){ this.user.nickname = value } } }  计算属性的结果会缓存
 computed:{ displayUsers(){ const hash = { male: &#39;男&#39;, female: &#39;女&#39; } const { users, gender } = this if(gender === &amp;quot;&amp;quot;){ return users } else if(typeof gender === &amp;quot;string&amp;quot;){ return users.filter(u =&amp;gt; u.gender === hash[gender]) } else { throw new Error(&amp;quot;意料之外的值&amp;quot;) } } },   watch  watch 是异步的，可以在数据变化之后立即使用 Vue.</description>
    </item>
    
    <item>
      <title>Grid布局</title>
      <link>https://mambaneverout.github.io/post/grid%E5%B8%83%E5%B1%80/</link>
      <pubDate>Sat, 21 Dec 2019 20:59:43 +0800</pubDate>
      
      <guid>https://mambaneverout.github.io/post/grid%E5%B8%83%E5%B1%80/</guid>
      <description>grid 布局是一种二维布局模型，先在页面上画好“虚拟格子”，再设置元素在格子上的位置和跨度 容器属性  声明使用 flex 布局  display: grid; / inline-grid  画好虚拟表格  grid: 30px auto 30px / 10% 1fr 10% (3 行 3 列) grid-gap: 10px 20px; (行与列之间的间隙)  告诉内容如何放置  align-items: start | end | center | stretch; justify-items: start | end | center | stretch; align-content: start; justify-content: space-evenly;  子项属性  grid-column： 3 / span 2; (从第三条线开始，跨越两个格子 =&amp;gt; 3 / 5) grid-row: 3 / 4; justify-self: start; align-self: center;   掘金首页 &amp;lt;body&amp;gt; &amp;lt;header&amp;gt;header&amp;lt;/header&amp;gt; &amp;lt;div class=&amp;quot;subnav&amp;gt;subnav&amp;lt;/div&amp;gt; &amp;lt;main&amp;gt;main&amp;lt;/main&amp;gt; &amp;lt;aside&amp;gt;aside&amp;lt;/aside&amp;gt; &amp;lt;/body&amp;gt;  body{ display: grid; grid: auto auto auto / 1fr 800px 180px 1fr; } header{ grid-area:1/2/2/4; } .</description>
    </item>
    
    <item>
      <title>定位与层叠上下文</title>
      <link>https://mambaneverout.github.io/post/%E5%AE%9A%E4%BD%8D%E4%B8%8E%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/</link>
      <pubDate>Sat, 21 Dec 2019 09:25:43 +0800</pubDate>
      
      <guid>https://mambaneverout.github.io/post/%E5%AE%9A%E4%BD%8D%E4%B8%8E%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87/</guid>
      <description>定位 position:static  元素在文档常规流中当前的布局位置 top, right, bottom, left 和 z-index 属性无效 用来取消元素的定位  position:relative  元素在文档流中占据的位置不会改变 视觉上位置改变了，不会影响其他元素  position:absolute  脱离了文档流 left: 10px 是自己的外边距相对于参考元素的边框内壁偏移 10px。 如果不设置 left/top，或者设为 auto，则绝对定位元素的位置处于默认位置 绝对定位的元素的宽度不会撑开父元素 给行内元素设置绝对定位后就有了块级的特性，可以设置宽高  position:fixed  相对于浏览器窗口 一定要设置 top/bottom  position:sticky  一定要设置 top 当页面向下滚动时，被视窗顶部拦住，被父级块元素下边缘推走 如果出现多个 sticky，放置在同一容器内，会出现下一个 sticky 元素把上一个“覆盖”的效果 如果出现多个 sticky，放置在并列的多个块级容器内，会出现下一个 sticky 元素把上一个“推走”的效果  使用经验  position:relative 做轻微的偏移，比如图标位置不齐 position:absolute 适用出现元素重叠、放置任意位置的场景 position:fixed 适用需持续固定在浏览器某位置的场景 position:sticky 标题随页面滚动，到顶部固定  层叠上下文   常见的创建层叠上下文的情况：
 z-index: 0 display: flex opacity 小于 1 的元素 transform  opacity: 0.</description>
    </item>
    
    <item>
      <title>Vue数据响应式</title>
      <link>https://mambaneverout.github.io/post/vue%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/</link>
      <pubDate>Fri, 20 Dec 2019 09:20:32 +0800</pubDate>
      
      <guid>https://mambaneverout.github.io/post/vue%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/</guid>
      <description>“Vue 是一套用于构建用户界面的渐进式框架，Vue 的核心库只关注视图层。” Vue 文档已经把 Vue 的特点说的很清楚了，Vue 是专注于 UI 界面的框架，数据的修改会实时的反馈到界面中。这就是数据响应式了，通过数据来驱动视图。 在 Vue 文档深入响应式原理中，Vue 是这样说的：“ 当你把一个对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。 ”那么 Vue 具体是怎么做的呢？
Vue 响应式原理: https://cn.vuejs.org/v2/guide/reactivity.html
1.先来了解一下 getter, setter 和 Object.defineProperty  getter: 不要括号就可以调用的函数
let obj2 = { 姓: &amp;quot;高&amp;quot;, 名: &amp;quot;圆圆&amp;quot;, get name() { return this.姓 + this.名; }, }; console.log(&amp;quot;需求二：&amp;quot; + obj2.name);  setter: 传入一个值并把这个值赋值给其他变量
let obj3 = { 姓: &amp;quot;高&amp;quot;, 名: &amp;quot;圆圆&amp;quot;, get name() { return this.</description>
    </item>
    
    <item>
      <title>初识Vue</title>
      <link>https://mambaneverout.github.io/post/%E5%88%9D%E8%AF%86vue/</link>
      <pubDate>Tue, 17 Dec 2019 12:06:38 +0800</pubDate>
      
      <guid>https://mambaneverout.github.io/post/%E5%88%9D%E8%AF%86vue/</guid>
      <description>创建项目
vue create vue-demo // 或者 codesandbox.io 上创建   Vue 选项
Babal (*) TypeScript Progressive Web App (PWA)Support Router Vuex CSS Pre-processors * // css预处理器 Linter/Formatter (*) Unit Testing * // 单元测试 E2E Testing  Lint 提示
Lint on save // 保存时提示 Lint and fix on commit // 提交时提示  unit testing
Jest  preset for future projects : N
  vue.js 与 vue.runtime.js
 vue.js(完整版):
 我有 complier(编译器) 可以直接写在 html 里或者写在 template 中 体积会大一些</description>
    </item>
    
    <item>
      <title>CSS选择器</title>
      <link>https://mambaneverout.github.io/post/css%E9%80%89%E6%8B%A9%E5%99%A8/</link>
      <pubDate>Thu, 12 Dec 2019 12:45:52 +0800</pubDate>
      
      <guid>https://mambaneverout.github.io/post/css%E9%80%89%E6%8B%A9%E5%99%A8/</guid>
      <description>通用选择器
* { box-sizing: border-box; } .box *{ font-size: 24px; }  属性选择器
[disabled]{ border:1px solid #ccc; } [type=&amp;quot;text&amp;quot;]{ border:1px solid #ccc; } [id=&amp;quot;title&amp;quot;]{ border:1px solid #ccc; } [data-color=&amp;quot;gray&amp;quot;]{ color: #666; }  不常用的选择器
 [attr~=val] 仅选择 attr 属性的值（以空格间隔出多个值）中有包含 val 值的所有元素，比如位于被空格分隔的多个类（class）中的一个类。
[class~=&amp;quot;aa&amp;quot;]{}  [attr*=val] 选择 attr 属性的值中包含字符串 val 的元素。
[href*=&amp;quot;baidu.com&amp;quot;]{}  [attr^=val] 选择 attr 属性的值以 val 开头（包括 val）的元素。
[data-name^=&amp;quot;frank&amp;quot;]{}  [attr$=val] 选择 attr 属性的值以 val 结尾（包括 val）的元素。
[data-name$=&amp;quot;1&amp;quot;]{}  [attr|=val] 选择 attr 属性的值是 val 或以 val-开头的元素（-用来处理语言编码）。</description>
    </item>
    
    <item>
      <title>MVC</title>
      <link>https://mambaneverout.github.io/post/mvc/</link>
      <pubDate>Tue, 10 Dec 2019 16:44:18 +0800</pubDate>
      
      <guid>https://mambaneverout.github.io/post/mvc/</guid>
      <description>MVC
 Model (数据) 负责操作所有数据
const m = { data:{} }  View (视图) 负责所有 UI 界面
const v = { el: null, html:` &amp;lt;div&amp;gt; &amp;lt;button&amp;gt;点我&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; `, init(container){}, render(){} }  Controller (控制器) 负责其他
const c = { init(container){}, events:{}, autoBindEvents(){} }   EventBus(事件总线)
 对象间的通信，负责 Model,View,Controller 之间的通信。
 on 监听事件
 trigger 触发事件/emit 发送事件
 once 事件执行一次
 off 移除事件监听
 jQuery
import $ from &#39;jQuery&#39; const eventBus = $(window) // const eventBus = $({}) eventBus.</description>
    </item>
    
    <item>
      <title>JS继承</title>
      <link>https://mambaneverout.github.io/post/js%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Tue, 10 Dec 2019 10:04:19 +0800</pubDate>
      
      <guid>https://mambaneverout.github.io/post/js%E7%BB%A7%E6%89%BF/</guid>
      <description>JS 实现继承有两种通用的方式  构造函数 + 原型
 不写 Parent.call(this, name1) 注释掉 Parent.call(this, name1)之后，执行 pMethod 函数，pMethod 函数被 child 调用，this 指向 child，但在 child 中无法找到 name1，所以输出 undefined。
 正确代码 正确代码，需要把 this 指向通过 new Child 构造出来的实例对象(child)，并且把参数 name1 传给 Parent。
 终极代码
function Parent(name1){ this.name1 = name1 } Parent.prototype.pMethod = function(){ console.log(this.name1) } function Child(name2, name1){ Parent.call(this, name1) // 得分点 this.name2 = name2 } Child.prototype.__proto__ = Parent.prototype //上面这句代码的古板写法应该是下面三句 //const empty = function(){} //empty.prototype = Parent.</description>
    </item>
    
    <item>
      <title>JQuery设计思想</title>
      <link>https://mambaneverout.github.io/post/jquery%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</link>
      <pubDate>Sun, 24 Nov 2019 10:05:32 +0800</pubDate>
      
      <guid>https://mambaneverout.github.io/post/jquery%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</guid>
      <description>jQuery 获取元素
 将一个表达式，放进构造函数 jQuery()（简写为\$），然后得到被选中的元素。
 表达式可以是 CSS 选择器：
$(document) // 选择整个文档 $(&#39;#myId&#39;) // 选择ID为myId的网页元素 $(&#39;div.myClass) // 选择class为myClass的div元素 $(&#39;input[name=first]&#39;) // 选择name属性等于first的input元素  也可以是 jQuery 特有的表达式
$(&#39;a:first&#39;) //选择网页中第一个a元素 $(&#39;tr:odd&#39;) //选择表格的奇数行 $(&#39;#myForm :input&#39;) // 选择表单中的input元素 $(&#39;div:visible&#39;) //选择可见的div元素 $(&#39;div:gt(2)&#39;) // 选择所有的div元素，除了前三个 $(&#39;div:animated&#39;) // 选择当前处于动画状态的div元素  jQuery 还支持对选中的元素进行过滤，对找到的元素再次进行筛选
　$(&#39;div&#39;).has(&#39;p&#39;); // 选择包含p元素的div元素 $(&#39;div&#39;).not(&#39;.myClass&#39;); //选择class不等于myClass的div元素 $(&#39;div&#39;).filter(&#39;.myClass&#39;); //选择class等于myClass的div元素 $(&#39;div&#39;).first(); //选择第1个div元素 $(&#39;div&#39;).eq(5); //选择第6个div元素  也可以获取附近的相关元素(父子元素，兄弟元素)
　$(&#39;div&#39;).next(&#39;p&#39;); //选择div元素后面的第一个p元素 $(&#39;div&#39;).parent(); //选择div元素的父元素 $(&#39;div&#39;).closest(&#39;form&#39;); //选择离div最近的那个form父元素 $(&#39;div&#39;).children(); //选择div的所有子元素 $(&#39;div&#39;).siblings(); //选择div的同级元素   jQuery 的链式操作</description>
    </item>
    
    <item>
      <title>JS函数的执行时机</title>
      <link>https://mambaneverout.github.io/post/js%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/</link>
      <pubDate>Fri, 15 Nov 2019 21:03:05 +0800</pubDate>
      
      <guid>https://mambaneverout.github.io/post/js%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/</guid>
      <description> 解释为什么如下代码会打印 6 个 6
let i = 0 for(i = 0; i&amp;lt;6; i++){ setTimeout(()=&amp;gt;{ console.log(i) },0) }   for 循环遍历 6 次，会执行 6 次 console.log() 当执行第 6 次循环的时候，i 为 5，console.log(5)之后，执行 i++，i 的值变为 6 只有一个全局变量 i，在 for 循环结束后，i 的值为 6，console.log(i)就会打印出 6  写出让上面代码打印 0、1、2、3、4、5 的方法
for(let i = 0; i&amp;lt;6; i++){ setTimeout(()=&amp;gt;{ console.log(i) },0) }  函数的要素
 调用时机 作用域 闭包 形参 返回值 调用栈 函数提升 arguments this   </description>
    </item>
    
    <item>
      <title>JS对象基本用法</title>
      <link>https://mambaneverout.github.io/post/js%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</link>
      <pubDate>Wed, 13 Nov 2019 17:51:42 +0800</pubDate>
      
      <guid>https://mambaneverout.github.io/post/js%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</guid>
      <description>对象基本知识
 声明对象的两种语法
- let obj = { &#39;name&#39;:小明, &#39;age&#39;:18 } - let obj = new Object({ &#39;name&#39;:小明, &#39;age&#39;:18 })  注意：
 键名是字符串，引号省略也是字符串（symbol 也可以作为属性名） 引号可以省略，省略之后只能写标识符  变量作为属性名
let a = &#39;mmp&#39; let obj = {a: &#39;emm&#39;} // obj.a let obj = {[a]: &#39;emm&#39;} // obj[a]   如果使用 [ ] 语法，那么 JS 会先求 [ ] 中表达式的值，注意区分表达式是变量还是常量。 如果使用点语法，那么点后面一定是 string 常量。  对象的原型
 每个对象都有一个隐藏属性，保存着原型的地址 共有属性组成的对象叫原型   删除对象的属性
- delete obj.</description>
    </item>
    
    <item>
      <title>JS基本语法</title>
      <link>https://mambaneverout.github.io/post/js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Tue, 12 Nov 2019 12:54:20 +0800</pubDate>
      
      <guid>https://mambaneverout.github.io/post/js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</guid>
      <description>表达式和语句  表达式  1 + 2 表达式的值为 3 add(1,2) 表达式的值为函数的返回值 console.log 表达式的值为函数本身 console.log(3) 表达式的值为 undefined  语句  var a = 1 是一个语句  区别  表达式一般都有值，语句可以有也可以没有 语句一般是用来改变环境的（声明，赋值）  注意：return 后面不能加回车  标识符的规则  第一个字符可以是 Unicode 字母 或者 \$ 或者 _ 或者 中文 后面的字符包括上面的说有，还可以有数字 变量名是标识符，还有其他标识符  if else 语句 / switch 语句
 if else 语句
 推荐写法：
if (表达式) { 语句 } else if (表达式) { 语句 } else { 语句 }  可以省略{}，但是省略后 if else 语句只会默认把后面的第一句放入{}内</description>
    </item>
    
    <item>
      <title>JavaScript的诞生</title>
      <link>https://mambaneverout.github.io/post/javascript%E7%9A%84%E8%AF%9E%E7%94%9F/</link>
      <pubDate>Mon, 04 Nov 2019 23:38:03 +0800</pubDate>
      
      <guid>https://mambaneverout.github.io/post/javascript%E7%9A%84%E8%AF%9E%E7%94%9F/</guid>
      <description>JavaScript 发展重要时间点：
 1994 年，网景公司发布了 Navigator 浏览器 0.9 版。这是历史上第一个比较成熟的网络浏览器。但是，这个浏览器只能用来浏览，不具备与访问者互动的能力 1995 年 5 月，网景公司决定创造一门网页脚本语言，随后布兰登只用 10 天时间就设计出来了 Javascript 2004 年 4 月 1 日，谷歌发布 Gmail 在线网页 2005 年，Jesse 将谷歌用到的技术命名为 AJAX，前端技术正式出现 2006 年，jQuery 发布，并且在之后的十年里占据了前端技术的主要地位 2009 年，Ryan 基于 V8 创建了 Node.js 2010 年，Isaac 基于 Node.js 写出来 npm 2010 年，TJ 发布了 Express.js  ECMAScript 标准的制定
 1997 年 6 月，第一版 ECMAScript 发布
 1999 年 12 月，ES3 发布，这是目前使用最广泛的版本
 2009 年 12 月，ES5 发布，增加了一些功能</description>
    </item>
    
    <item>
      <title>浅析URL</title>
      <link>https://mambaneverout.github.io/post/%E6%B5%85%E6%9E%90url/</link>
      <pubDate>Tue, 29 Oct 2019 12:53:44 +0800</pubDate>
      
      <guid>https://mambaneverout.github.io/post/%E6%B5%85%E6%9E%90url/</guid>
      <description>URL
 URL 的内容：协议 + 域名或 IP + 端口号 + 路径 + 查询参数字符串 + 锚点 https + www.baidu.com + /s + ?wd=hello&amp;amp;rsv_spt=1 + #5  协议：使用 http 还是 https 域名：baidu.com 端口号：默认不写（http 为 80，https 为 443) 路径：请求不同的页面 查询参数字符串：查询的内容 锚点：访问不同位置的内容（不支持中文，不会传给服务器）   DNS ，nslookup 命令
 域名系统（Domain Name System）是将域名和 IP 地址相互映射的一个分布式数据库。
 DNS 的作用是让域名和 IP 对应起来
 nslookup baidu.com
  IP ，ping 命令
 Internet Protocal  如何让定位一台设备 如何封装数据报文，以跟其他设备交流  内网 IP(路由器) 外网 IP(ipconfig) 特殊的 IP  127.</description>
    </item>
    
    <item>
      <title>CSS知识总结</title>
      <link>https://mambaneverout.github.io/post/css%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 27 Oct 2019 14:15:01 +0800</pubDate>
      
      <guid>https://mambaneverout.github.io/post/css%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</guid>
      <description>一、 浏览器渲染原理
 根据 HTML 构建 HTML 树（DOM） 根据 CSS 构建 CSS 树（CSSOM） 将两棵树合并成一颗渲染树（render tree) Layout 布局 （文档流、盒模型、计算大小和位置） Paint 绘制（把边框颜色、文字颜色、阴影等画出来） Composite 合成（根据层叠关系展示画面）  二、 CSS 动画 transition
 transform
 语法：
transform:translate(-50%, -50%)  组合使用
transform: scale(0.5) translate(-100%,-100%)   transform: none; 取消所有效果  translate（位移）
 translateX() translateY() translate() translateZ() translate3d()  scale（缩放）
 scaleX() scaleY() scale()  rotate（旋转）
 rotate() rotateZ() rotateX() rotateY() rotate3d()  skew（倾斜）
 skewX() skewY() skew()  注意：inline 元素不支持 transform</description>
    </item>
    
    <item>
      <title>HTML常用标签</title>
      <link>https://mambaneverout.github.io/post/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Wed, 23 Oct 2019 15:57:32 +0800</pubDate>
      
      <guid>https://mambaneverout.github.io/post/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</guid>
      <description>a 标签
 href：超链接，网址
 网址: //google.com (使用这种方式即可，自动选择使用 http 或者 https)
 路径: 以开启 http 服务的文件夹为根目录查找文件
 伪协议: javascript: 代码 如果需要点击 a 标签后什么都不会发生，则需要下面的代码。
&amp;lt;a href=&amp;quot;javascript:;&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;  mailto: 邮箱
 tel: 手机号
 id href=#xxx 跳转到 id 为 xxx 的元素的位置
  target：打开方式
 _blank（新窗口打开） _top（在祖先元素中加载。如果没有祖先元素，则在当前页面加载） _parent（在父元素中加载。同_top) _self（当前页面加载） 任意字符串（在同一个窗口中打开不同的页面）  download：下载（没什么用）
 rel=noopener
  iframe 标签 内联框架元素，它能够将另一个 HTML 页面嵌入到当前页面中。
 Chrome 浏览器不允许任何 iframe 标签指向 TA。  table 标签
 thead tbody tfoot tr: 行 th: 表头 td: 表格单元格 table-layout: auto （内容决定宽度）/fixed （宽度平均） border-collapse: collapse; border 合并 border-spacing: 0; border 之前的距离  img 标签（永远不要让图片变形）</description>
    </item>
    
    <item>
      <title>HTML入门笔记1</title>
      <link>https://mambaneverout.github.io/post/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/</link>
      <pubDate>Wed, 23 Oct 2019 11:25:50 +0800</pubDate>
      
      <guid>https://mambaneverout.github.io/post/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/</guid>
      <description> HTML是由蒂莫西·约翰·“蒂姆”·伯纳·李爵士发明的，他也是万维网的发明者。
 HTML起手式： VS Code中创建一个HTML页面，输入!（注意是英文状态下的!），然后按 Tab 键即可创建一个基础的HTML。
 常用的表章节的标签：
 header: 头部 footer: 脚部 h1~h6：标题 p: 段落 section: 章节 article: 文章 main: 主要内容 aside: 旁支内容（侧边导航栏） div: 划分（万能标签）  全局属性：
 class：CSS书写样式常用 contenteditable：标签变为可编辑的 hidden：隐藏该标签 id：尽量不要使用 style：设置样式 tabindex：Tab键访问 title：标题，显示完整内容  常用的内容标签：
 ol+li：有序列表 ul+li：无序列表 dl+dt+dd：键值对列表 a：超链接（添加target=&amp;rdquo;_blank&amp;rdquo;，在新标签打开网页) strong：内容上的强调 em：语气上的强调 code：显示代码，默认字体是等宽的 pre：包裹的内容中的空格和换行都会显示出来 hr：分割线 br：换行 quote：内联引用 blockquote：块级引用   </description>
    </item>
    
    <item>
      <title>如何用hugo搭建个人博客</title>
      <link>https://mambaneverout.github.io/post/%E5%A6%82%E4%BD%95%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Tue, 22 Oct 2019 14:47:50 +0800</pubDate>
      
      <guid>https://mambaneverout.github.io/post/%E5%A6%82%E4%BD%95%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid>
      <description>大家好啊，第一篇博客就来介绍一下如何用hugo搭建一个简单的个人博客。  安装Hugo,下载链接：https://github.com/gohugoio/hugo/releases。
hugo version  下载完成后可以通过下面的指令检测是否下载成功。
 建立新网站
hugo new site blog  上面的代码将在名为的文件夹中创建一个新的Hugo网站blog。
 添加主题(默认主题为Ananke主题)
cd blog git init git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke echo &#39;theme = &amp;quot;ananke&amp;quot;&#39; &amp;gt;&amp;gt; config.toml  创建新的博客
hugo new post/开博.md  可以编辑新创建的文件内容，它将从以下内容开始：
--- title: &amp;quot;开博&amp;quot; date: 2019-10-22T08:47:11+01:00 draft: true ---  注意：draft 是指草稿的意思，默认是true（不显示），写完博客记得修改为false，然后才会在你的博客中显示。
 启动Hugo服务器
hugo server -D  默认在 http://localhost:1313 中显示。
  一个简单的hugo博客就搭建完成了，可以开始写自己的博客啦！</description>
    </item>
    
    <item>
      <title>开博</title>
      <link>https://mambaneverout.github.io/post/%E5%BC%80%E5%8D%9A/</link>
      <pubDate>Mon, 21 Oct 2019 15:53:29 +0800</pubDate>
      
      <guid>https://mambaneverout.github.io/post/%E5%BC%80%E5%8D%9A/</guid>
      <description> 大家好，我的博客开通了。 </description>
    </item>
    
  </channel>
</rss>